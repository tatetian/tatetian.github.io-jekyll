---
layout: post
title: SSH Essentials in Three Steps
---

I have been using Linux for almost ten years. And SSH has been an indespensible
tool from the early days of my journey in exploring Linux. Throughout the
years, I learned bits and pieces about SSH, from basic usage to advanced
tricks. After recently reading a book named [SSH Mastery: OpenSSH, PuTTY,
Tunnels and
Keys](http://www.amazon.com/SSH-Mastery-OpenSSH-PuTTY-Tunnels/dp/1470069717/),
I am now confident that my knowledge about SSH covers most of its features.

While mastering all [the dark magic of SSH](https://vimeo.com/54505525) demands
quite an effort, learning the essentials—the most useful tips and tricks— does
not. In this post, I want to share with you the essentials of SSH.

(This post focuses on the open-source implementation of SSH, OpenSSH. Sorry, Windows folks!)

## Big Picture: The Three Steps
Secure Shell, or SSH, is a network tool whose primary goal is to allow an user
to login a machine *remotely* and *securely*. 

To this aim, SSH works in the following three steps:

* **Server validation**: SSH client checks if the SSH server being connected to is really what it claims (by looking up the entries in `~/.ssh/known_hosts`);
* **User authentication**: SSH client tries to login the SSH server by providing user’s credential (e.g. public key in `~/.ssh/id_rsa.pub`);
* **Secure data transfer**: Data transfer occurs in the secure channel established between the SSH client and server. On the secure channel, various network protocols (e.g. ftp, X protocol, socket) can be supported.

### Server Validation
To prevent a user from logining into a wrong machine accidentally, SSH client
maintains the records of machine key signatures in `~/.ssh/known_hosts`. When a
SSH client connects to a machine for the first time, a new record (the IP and
key signature of the machine), will be appended to the `known_hosts` file.
Later when the SSH client connects to the machine again, the key signature
provided by the machine this time will be compared with the recorded signature.
If they don’t match, the connection attempt will be terminated by SSH client.

In some situations, e.g. reinstallation of operating system or IP being
occupied by another machine, the records in `~/.ssh/known_hosts` can become
invalid. The invalid records must be deleted from `known_hosts` file so that
the SSH client will not forbid users’ connection attempt.

### User Authentication
Password is the most common way of user authentication. While using password is
very intuitive, it may not be sufficient in some situations when, for example,
password is not secure enough (if brute-force attack is a concern), or when
entering password is tedious or even impossible (running automated scripts on a
cluster of machines). 

Public key authentication can provide higher security and more convenience. In
a SSH server, the public keys that can be used to login are recorded in
`~/.ssh/authorized_keys`. With a private key that matches one of the public
key, a SSH client can be granted access to the server.

Public key is the default authentication method of Linux instances in cloud
([Amazon AWS](aws.amazon.com) or [OpenStack](https://www.openstack.org/)). In a
Web console of cloud platform, a cloud instance can be configured to using a
public key specified by user, which will be inserted into
`~/.ssh/authorized_keys` file on boot. After launched, the instance can grant
access to any SSH client that uses the corresponding private key. In OpenSSH
client, this can be done by using the `-i` parameter, for example,  `ssh -i
identity.pem ubuntu@cloud-node`.  

If the `-i` parameter is not given to specify the file that contains the
identity (private key), then OpenSSH client will try to read the identity from
the default file `~/.ssh/id_XXX`, whose public key counterpart is
`~/.ssh/id_XXX.pub` (where `XXX` can be either `dsa`, `ecdsa` or `rsa`,
representing the type of key). Keys can be generated by `ssh-keygen` utility.
As it may become clear by now, appending the public key in your
`~/.ssh/id_XXX.pub` to `~/.ssh/authorized_keys` on another machine can grant
you access to the machine without entering password.

### Secure Data Transfer
Despite its initial goal of allowing a user to login a shell remotely and
securely (as its name suggests), SSH can serve multiple purposes. With
flexiblity and extensiblity in mind, SSH has been designed as a three-layer
architecture, which includes the transport layer, the user authentication layer
and the connection layer. A single SSH connection can host multiple channels of
different types, each of which may serve different purpose. The net effect is
that SSH is very versatile in usage, for example:

* **Secure copy (`scp`)**, which emulates the interface of cp command, is convenient to transfer files between machines;
* **SSH File Transfer Protocol (`sftp`)**, which emulates the behaviour of FTP protocol, offers file transfer as well as directionary manipulation;
* **X forwarding (`-X` parameter)**, allows a remote shell to run applications with GUI backed by X server;
* **Port forwarding**, tunnels arbitrary TCP traffics.

## Port Forwarding
Port forwarding is a very powerful yet somewhat confusing feature that deserves
further elaboration.

The three types of port forwarding---Local forwarding, remote forwarding and
dynamic forwarding— are similar but different.

### Local Forwarding
![Local forwarding]({{ site.baseurl }}public/img/ssh-essentials/local_forwarding.png)

Local forwarding enables local-side machines  to connect to a remote-side
machine through a SSH tunnel. This can be useful, for example, when you want to
access  a database that only allows connection from localhost. 

The option for local forwarding in OpenSSH client is `-L
[local_address:]local_port:target_host:target_port`. Set `local_address` to `*`
if you want to the socket listening to port `local_port` on all interfaces of
the local-side machine running SSH client.

### Remote Forwarding
![Remote Forwarding]({{ site.baseurl }}public/img/ssh-essentials/remote_forwarding.png)

Conversely, remote forwarding gives remote-side machines the ability to connect
to a client-side machine through a SSH tunnel. This is particularly useful when
you want to temporaly publish a service on a machine that is behind a NAT
router or firewall.

The option for remote forwarding in OpenSSH client is `-R
[remote_address:]remote_port:target_host:target_port`. Set `remote_address` to
`*` if you want to the socket listening to port `remote_port` on all interfaces
of the remote-side machine running SSH server.

### Dynamic Forwarding
![Dynamic Forwarding]({{ site.baseurl }}public/img/ssh-essentials/dynamic_forwarding.png)

While local/remote forwarding redirect all the traffic to one target---a
specific port of a specific machine, dynamic forwarding gets rid of the
restriction by providing a SOCK proxy interface.  This SSH-as-a-proxy feature
is one of my favourite as it allows me (who lives in China) to penetrate the
Great Firewall of China by redirecting the traffic of my browser to a SOCK
proxy backed by a ssh connection to an Amazon AWS instance (Thanks Amazon for 
your first-year free trial policy!).

The option for dynamic forwarding in OpenSSH client is `-D
[local_address:]local_port.` The parameter `local_address` can be set to `*`
with same meaning as in local forwarding and remote forwarding.

## Closing remarks
This post is by no means comprehensive. Yet, I hope it gives an interesting
introduction to the essentials of SSH, and clears up confusion about the port
forwarding of SSH. One important topic that is missing in this post is [SSH
config](http://linux.die.net/man/5/ssh_config), which can really [simplify your
life](http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/).
